I"æ¬<p>This document provides the information necessary to configure the COSMOS Command and Telemetry Server and other top level configuration options for your unique project.</p>

<p>Configuration file formats for the following are provided:</p>

<ul>
  <li>system.txt (found in config/system)</li>
  <li>target.txt (found in config/targets/TARGETNAME)</li>
  <li>cmd_tlm_server.txt (found in config/targets/TARGETNAME and config/tools/cmd_tlm_server)</li>
  <li>crc.txt (found in data/crc.txt)</li>
</ul>

<h1 id="system-configuration">System Configuration</h1>
<p>The COSMOS system configuration is performed by system.txt in the config/system directory. This file declares all the targets that will be used by COSMOS as well as top level configuration information which is primarily used by the Command and Telemetry Server.</p>

<p>By default, all COSMOS tools use the config/system/system.txt file. However, all tools can take a custom system configuration file by passing the ‚Äú‚Äìsystem <filename>" option to the tool when it starts. NOTE: Mixing system configuration files between tools can be confusing as some tools could be configured with more or less targets than the Command and Telemetry Server. However, this is the only way to control which targets, ports, paths, and log writers are used by the various tools.</filename></p>

<h2 id="auto_declare_targets">AUTO_DECLARE_TARGETS</h2>
<p><strong>Automatically load all the target folders under config/targets into the system</strong></p>

<p>When automatically discovering target folders the COSMOS naming convention must be followed. Target folders must be uppercase and be named according to how COSMOS will access them. For example, if you create a config/targets/INST directory, COSMOS will create a target named ‚ÄòINST‚Äô which is how it will be referenced. This keyword is REQUIRED unless you individually declare your targets using the DECLARE_TARGET keyword.</p>

<h2 id="declare_target">DECLARE_TARGET</h2>
<p><strong>Declare a COSMOS target and name it</strong></p>

<p>Declare target is used in place of AUTO_DECLARE_TARGETS to give more fine grained control over how the target folder is loaded and named within COSMOS. This is required if AUTO_DECLARE_TARGET is not present.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Target Name</td>
      <td>The directory name which contains the target information. This must match a directory under config/targets.<br /><br />Valid Values: <span class="values">Any Target Name</span></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Substitute Target Name</td>
      <td>The target name in the COSMOS system. This is how the target will be referred to in scripts. If this is not given (or given as nil) the target name will be the directory name given above.</td>
      <td>False</td>
    </tr>
    <tr>
      <td>Target Filename</td>
      <td>The name of the file in the target directory which contains the configuration information for the target. By default this is ‚Äòtarget.txt‚Äô but if you want to rename this you need to set this parameter.</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">DECLARE_TARGET INST INST2 inst.txt</code></pre></figure>

<h2 id="declare_gem_target">DECLARE_GEM_TARGET</h2>
<p><strong>Declare a COSMOS target which resides in a Ruby gem</strong></p>

<p>COSMOS targets can be distributed in gem form in which case they must be named ‚Äòcosmos-<gem-name>' where <gem-name> is the descriptive name of the gem. See the COSMOS documentation at cosmosrb.com for for information on creating a COSMOS gem target.</gem-name></gem-name></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Gem Name</td>
      <td>The COSMOS gem name which must be cosmos-<gem-name> where <gem-name> is the descriptive gem name. In the above example, the target will be named 'GEM-NAME' (note the cosmos- prefix is stripped off).</gem-name></gem-name></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Substitute Target Name</td>
      <td>The target name in the COSMOS system. This is how the target will be referred to in scripts. If this is not given (or given as nil) the target name will be the gem name as described above.</td>
      <td>False</td>
    </tr>
    <tr>
      <td>Target Filename</td>
      <td>The name of the file in the target directory which contains the configuration information for the target. By default this is ‚Äòtarget.txt‚Äô but if you want to rename this you need to set this parameter.</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<h2 id="declare_gem_multi_target">DECLARE_GEM_MULTI_TARGET</h2>
<p><strong>Declare a COSMOS target which resides in a Ruby gem with multiple targets</strong></p>

<p>COSMOS targets can be distributed in gem form in which case they must be named ‚Äòcosmos-<gem-name>' where <gem-name> is the descriptive name of the gem. Multiple Targets can be packaged into a single gem. This directive will tell COSMOS where to look for a target inside the first directory level of the gem.  The sub-directory name must be all uppercase and must contain a sub-directory named 'cmd_tlm'. See the COSMOS documentation at cosmosrb.com for for information on creating a COSMOS gem target.</gem-name></gem-name></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Gem Name</td>
      <td>The COSMOS gem name which must be cosmos-<gem-name> where <gem-name> is the descriptive gem name. In the above example, the target will be named 'GEM-NAME' (note the cosmos- prefix is stripped off).</gem-name></gem-name></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Target Name</td>
      <td>The directory name which contains the target information. This must match a directory under the first level of the gem base directory.</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Substitute Target Name</td>
      <td>The target name in the COSMOS system. This is how the target will be referred to in scripts. If this is not given (or given as nil) the target name will be the gem name as described above.</td>
      <td>False</td>
    </tr>
    <tr>
      <td>Target Filename</td>
      <td>The name of the file in the target directory which contains the configuration information for the target. By default this is ‚Äòtarget.txt‚Äô but if you want to rename this you need to set this parameter.</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<h2 id="port">PORT</h2>
<p><strong>Set a Server Port</strong></p>

<p>Port is used to set the default ports used by the Command and Telemetry Server. It is not necessary to set this option unless you wish to override the defaults (given in the example usage). Overriding ports is necessary if you want to run two Command and Telemetry Servers on the same computer simultaneously.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Port Name</td>
      <td>CTS_API - This port is what tools connect to to communicate with the COSMOS Scripting API. TLMVIEWER_API - This port is used to remotely open and close telemetry screens in Telemetry Viewer. CTS_PREIDENTIFIED - This port provides access to a preidentified stream of all telemetry packets in the system. This is currently used by Telemetry Grapher and can be used to chain Command and Telemetry Servers together as it also accepts commands. CTS_CMD_ROUTER - This port provides access to a stream of all command packets that have been accepted by COSMOS.<br /><br />Valid Values: <span class="values">CTS_API, TLMVIEWER_API, CTS_PREIDENTIFIED, CTS_CMD_ROUTER</span></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Port Value</td>
      <td>Port number to use for the specified port name</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">PORT CTS_API 7777 # Default
PORT TLMVIEWER_API 7778 # Default
PORT CTS_PREIDENTIFIED 7779 # Default
</code></pre></figure>

<h2 id="listen_host">LISTEN_HOST</h2>
<div class="right">(Since 4.0.0)</div>
<p><strong>IP addresses or host names to bind API ports to</strong></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Host Port Name</td>
      <td>CTS_API - This port is what tools connect to to communicate with the COSMOS Scripting API. TLMVIEWER_API - This port is used to remotely open and close telemetry screens in Telemetry Viewer. CTS_PREIDENTIFIED - This port provides access to a preidentified stream of all telemetry packets in the system. This is currently used by Telemetry Grapher and can be used to chain Command and Telemetry Servers together as it also accepts commands. CTS_CMD_ROUTER - This port provides access to a stream of all command packets that have been accepted by COSMOS.<br /><br />Valid Values: <span class="values">CTS_API, TLMVIEWER_API, CTS_PREIDENTIFIED, CTS_CMD_ROUTER</span></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Host Value</td>
      <td>The IP address or host name to bind the Host Port Name to. By default, the CTS_API and TLMVIEWER_API are bound to localhost meaning that only tools on the same machine can connect. By default, CTS_PREIDENTIFIED and CTS_CMD_ROUTER are bound to ‚Äò0.0.0.0‚Äô to allow for tools on any machines to connect. This allows for chaining two or more Servers out of the box.</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h2 id="connect_host">CONNECT_HOST</h2>
<div class="right">(Since 4.0.0)</div>
<p><strong>IP addresses or host names to connect tools to</strong></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Host Port Name</td>
      <td>CTS_API - This port is what tools connect to to communicate with the COSMOS Scripting API. TLMVIEWER_API - This port is used to remotely open and close telemetry screens in Telemetry Viewer. CTS_PREIDENTIFIED - This port provides access to a preidentified stream of all telemetry packets in the system. This is currently used by Telemetry Grapher and can be used to chain Command and Telemetry Servers together as it also accepts commands. CTS_CMD_ROUTER - This port provides access to a stream of all command packets that have been accepted by COSMOS.<br /><br />Valid Values: <span class="values">CTS_API, TLMVIEWER_API, CTS_PREIDENTIFIED, CTS_CMD_ROUTER</span></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Host Value</td>
      <td>The IP address or host name to connect tools to. By default all ports are bound to localhost so all tools connect to the local machine.</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h2 id="path">PATH</h2>
<p><strong>Set a Server Path</strong></p>

<p>Path is used to set the default paths used by the Command and Telemetry Server to access or create files. It is not necessary to set this option unless you wish to override the defaults (given in the example usage).</p>

<div class="note warning"><p>The PROCEDURES path must be set for Script Runner and Test Runner to locate your procedure files. You can add multiple 'PATH PROCEDURES' lines to your configuration file to set multiple locations.</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Path Name</td>
      <td>Path name to set.<br /><br />Valid Values: <span class="values">LOGS, TMP, SAVED_CONFIG, TABLES, PROCEDURES, HANDBOOK</span></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Path Value</td>
      <td>File system path to use for the specified path name</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">PATH LOGS './logs' # Default location of system and tool log files
PATH TMP './tmp' # Default location of temporary marshal files
PATH SAVED_CONFIG './saved_config' # Default location of saved configurations (see note)
PATH TABLES './tables' # Default location of table files
PATH PROCEDURES './procedures' # Default location of Script procedure files
PATH HANDBOOKS './handbooks' # Default location to place handbook files
</code></pre></figure>

<h2 id="default_packet_log_writer">DEFAULT_PACKET_LOG_WRITER</h2>
<p><strong>Set the class used when creating binary packet log files</strong></p>

<div class="note warning"><p>Overriding the default log writer can break the ability to write log files that COSMOS can interpret. Proceed with caution!</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Filename</td>
      <td>Ruby file to use when instantiating a new log writer</td>
      <td>True</td>
    </tr>
    <tr>
      <td>parameter</td>
      <td>Parameters which are passed to the log read upon initialization</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">DEFAULT_PACKET_LOG_WRITER packet_log_writer.rb</code></pre></figure>

<h2 id="default_packet_log_reader">DEFAULT_PACKET_LOG_READER</h2>
<p><strong>Set the class used when reading binary packet log file</strong></p>

<div class="note warning"><p>Overriding the default log read can break the ability to read log files. Proceed with caution!</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Filename</td>
      <td>Ruby file to use when instantiating a new log writer</td>
      <td>True</td>
    </tr>
    <tr>
      <td>parameter</td>
      <td>Parameters which are passed to the log read upon initialization</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">DEFAULT_PACKET_LOG_READER packet_log_reader.rb</code></pre></figure>

<h2 id="staleness_seconds">STALENESS_SECONDS</h2>
<p><strong>Number of seconds before marking the packet stale</strong></p>

<p>A stale packet is identified in telemetry screens by all the telemetry items in the stale packet being colored purple..</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Seconds</td>
      <td>Integer number of seconds before packets are marked stale</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">STALENESS_SECONDS 30</code></pre></figure>

<h2 id="enable_dns">ENABLE_DNS</h2>
<div class="right">(Since 3.5.0)</div>
<p><strong>Enable reverse DNS lookups for tools</strong></p>

<p>Enables reverse DNS lookups when tools connect to the Command and Telemetry Server‚Äôs pre-identified socket or to any target using the TCPIP Server Interface. As of COSMOS 3.5.0 the default is to not use DNS.</p>

<h2 id="disable_dns">DISABLE_DNS</h2>
<p><strong>Disable reverse DNS lookups for tools</strong></p>

<p>Disable reverse DNS lookups when tools connect to the Command and Telemetry Server‚Äôs pre-identified socket or to any target using the TCPIP Server Interface. This is useful when you are in an environment where DNS is not available. As of COSMOS 3.5.0 the default is to not use DNS</p>

<h2 id="enable_sound">ENABLE_SOUND</h2>
<div class="right">(Since 3.5.0)</div>
<p><strong>Enable audible sounds when popups occur</strong></p>

<p>Enable sound makes any prompts that occur in ScriptRunner/TestRunner make an audible sound when they popup to alert the operator of needed input.</p>

<h2 id="allow_access">ALLOW_ACCESS</h2>
<p><strong>White list machines that are allowed to connect to the Server</strong></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Name or IP Address</td>
      <td>Machine name to allow access or you can specify ‚ÄòALL‚Äô to allow all machines access</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ALLOW_ACCESS ALL</code></pre></figure>

<h2 id="meta_init">META_INIT</h2>
<div class="right">(Since 4.0.0)</div>
<p><strong>Specify a file to initialize the SYSTEM META packet</strong></p>

<p>Filename should be a text file with key value pairs where the keyword matches an item in the SYSTEM META packet. Note you do not have to specify ALL the items in the SYSTEM META packet.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Filename</td>
      <td>Filename, either fully qualified, or relative to Cosmos::USERPATH</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h2 id="time_zone_utc">TIME_ZONE_UTC</h2>
<div class="right">(Since 3.10.0)</div>
<p><strong>Report all times as UTC</strong></p>

<p>COSMOS will report all times as UTC time. If this keyword is not used, COSMOS will report all times as local times, where the local time zone is determined automatically by Ruby based upon the operating system time settings. This setting affects packet receive times, timestamped log filenames, message logs, Cmd/Tlm extractor time ranges, etc.</p>

<h2 id="add_hash_file">ADD_HASH_FILE</h2>
<div class="right">(Since 4.4.0)</div>
<p><strong>Add a file to the hashing sum calculation</strong></p>

<p>Adds a file to the set of files used in marshal file hashing sum calculation. Upon startup, COSMOS calculates a hashing sum over the command/telemetry definition files for all targets. After the definitions have been processed, COSMOS saves the resulting objects as marshal files in a folder with the hashing sum as part of the name. The next time COSMOS runs, if the hashing sum of the cmd/tlm definition files has not changed, COSMOS can load the marshal files instead of re-processing the definitions. If a file is specified with the ADD_HASH_FILE keyword, COSMOS will include it in the hashing sum calculation. This means that a change in the file will cause COSMOS to re-process the cmd/tlm defintions and create a new set of marshal files. The default hashing algorithm is MD5, but other Ruby Digest algorithms are also supported, like SHA1 and SHA256</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Filename</td>
      <td>Filename, either fully qualified, or relative to Cosmos::USERPATH</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ADD_HASH_FILE lib/user_version.rb</code></pre></figure>

<h2 id="classification">CLASSIFICATION</h2>
<div class="right">(Since 4.3.0)</div>
<p><strong>Add a classification banner to the top of all the COSMOS tools</strong></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
      <th>¬†</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Display Text</td>
      <td>The text to display in the classification banner</td>
      <td>True</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>Color Name</td>
      <td>Red Hex</td>
      <td>The color name or the red value of a RGB triplet</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Green Hex</td>
      <td>The green value of a RGB triplet</td>
      <td>False</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>Blue Hex</td>
      <td>The blue value of a RGB triplet</td>
      <td>False</td>
      <td>¬†</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">CLASSIFICATION Unclassified green
CLASSIFICATION Secret 255 114 0
</code></pre></figure>

<h2 id="hashing_algorithm">HASHING_ALGORITHM</h2>
<div class="right">(Since 4.4.0)</div>
<p><strong>Specify which Ruby Digest hashing algorithm to use</strong></p>

<p>Set the hashing algorithm used for config hashing, tlm_viewer hashing, and script hashing. COSMOS will truncate the resulting hash string down to 32 characters</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Algorithm</td>
      <td>Digest algorithm, one of MD5, RMD160, SHA1, SHA256, SHA384, SHA512</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">HASHING_ALGORITHM SHA256</code></pre></figure>

<h1 id="target-configuration">Target Configuration</h1>
<p>Each target is self contained in a target directory named after the target and placed in the config/targets directory. In the target directory there is a configuration file named target.txt which configures the individual target.</p>

<h2 id="require">REQUIRE</h2>
<p><strong>Requires a Ruby file</strong></p>

<p>Ruby files must be required to be available to call in other code. Files are first required from the target‚Äôs lib folder. If no file is found the Ruby system path is checked which includes the base COSMOS/lib folder.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Filename</td>
      <td>Filename to require. For files in the target‚Äôs lib directory simply supply the filename, e.g. ‚ÄúREQUIRE my_file‚Äù. Files in the base COSMOS lib directory also should just list the filename. If a file is in a folder under the lib directory then you must specify the folder name, e.g. ‚ÄúREQUIRE folder/my_file‚Äù. The filename can also be an absolute path but this is not common. Note the ‚Äú.rb‚Äù extension is optional when specifying the filename.</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">REQUIRE limits_response.rb</code></pre></figure>

<h2 id="ignore_parameter">IGNORE_PARAMETER</h2>
<p><strong>Ignore the given command parameter</strong></p>

<p>Hint to other COSMOS tools to hide or ignore this command parameter when processing the command. For example, Command Sender and Command Sequence will not display the parameter (by default) when showing the command and Script Runner code completion will not display the parameter.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Parameter Name</td>
      <td>The name of a command parameter. Note that this parameter will be ignored in ALL the commands it appears in.</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">IGNORE_PARAMETER CCSDS_VERSION</code></pre></figure>

<h2 id="ignore_item">IGNORE_ITEM</h2>
<p><strong>Ignore the given telemetry item</strong></p>

<p>Hint to other COSMOS tools to hide or ignore this telemetry item when processing the telemetry. For example, Packet Viewer will not display the item (by default) when showing the packet.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Item name</td>
      <td>The name of a telemetry item. Note that this item will be ignored in ALL the telemetry it appears in.</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">IGNORE_ITEM CCSDS_VERSION</code></pre></figure>

<h2 id="commands">COMMANDS</h2>
<p><strong>Process the given command definition file</strong></p>

<p>This keyword is used to explicitly add the command definition file to the list of command and telemetry files to process.</p>

<div class="note warning"><p>Usage of this keyword overrides automatic command and telemetry file discovery. If this keyword is used, you must also use the TELEMETRY keyword to specify the telemetry files to process.</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Filename</td>
      <td>Name of a command definition file in the target‚Äôs cmd_tlm directory, e.g. ‚Äúcmd.txt‚Äù.</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">COMMANDS inst_cmds_v2.txt
TELEMETRY inst_tlm_v2.txt
</code></pre></figure>

<h2 id="telemetry">TELEMETRY</h2>
<p><strong>Process the given telemetry definition file</strong></p>

<p>This keyword is used to explicitly add the telemetry definition file to the list of command and telemetry files to process.</p>

<div class="note warning"><p>Usage of this keyword overrides automatic command and telemetry file discovery. If this keyword is used, you must also use the COMMAND keyword to specify the command files to process.</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Filename</td>
      <td>Name of a telemetry definition file in the target‚Äôs cmd_tlm directory, e.g. ‚Äútlm.txt‚Äù.</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">COMMANDS inst_cmds_v2.txt
TELEMETRY inst_tlm_v2.txt
</code></pre></figure>

<h2 id="auto_screen_substitute">AUTO_SCREEN_SUBSTITUTE</h2>
<p><strong>Automatically substitute the target‚Äôs name in screen definitions</strong></p>

<p>Targets can be renamed when they are declared which would break any screen definitions using the explicit target name. This keyword automatically replaces the target name in the screen definitions with the actual target name.</p>

<div class="note warning"><p>Replaces ALL target names in a screen definition file, so this is not suitable for screens with multiple targets.</p></div>

<h2 id="cmd_unique_id_mode">CMD_UNIQUE_ID_MODE</h2>
<p><strong>Flags that commands to this target are identified in a mixed variety of ways</strong></p>

<p>Ideally all commands for a target are identified using the exact same fields in a header for each command.  If  this target identifies packets using different fields for some commands than others, then this flag must be set to force a brute force identification method.</p>

<div class="note warning"><p>Using this mode significantly slows packet identification</p></div>

<h2 id="tlm_unique_id_mode">TLM_UNIQUE_ID_MODE</h2>
<p><strong>Flags that telemetry to this target are identified in a mixed variety of ways</strong></p>

<p>Ideally all telemetry for a target are identified using the exact same fields in a header for each packet.  If  this target identifies packets using different fields for some telemetry packets than others, then this flag must be set to force a brute force identification method.</p>

<div class="note warning"><p>Using this mode significantly slows packet identification</p></div>

<h1 id="command-and-telemetry-server-configuration">Command and Telemetry Server Configuration</h1>
<p>The Command and Telemetry Server‚Äôs configuration file is found in config/tools/cmd_tlm_server. This file is used to configure the server by primarily mapping the interfaces to the targets they service.</p>

<h2 id="title">TITLE</h2>
<p><strong>Sets the Command and Telemetry Server window title</strong></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Text</td>
      <td>Text to put in the title of the Command and Telemetry Server window</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h2 id="packet_log_writer">PACKET_LOG_WRITER</h2>
<p><strong>Declare a packet log writer</strong></p>

<p>Packet log writer is used to declare a packet log writer class and give it a name which can be referenced by an interface. This is required if you want interfaces to have their own dedicated log writers or want to combine various interfaces into a single log file. By default, COSMOS logs all data on all interfaces into a single command log and a single telemetry log. This keyword can also be used if you want to declare a different log file class to create log files.</p>

<div class="note warning"><p>You should NOT override the default without consulting a COSMOS expert as this may break the ability to successfully read and write log files.</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Log Writer Name</td>
      <td>The name of the log writer as reference by other cmd_tlm_server keywords. This name also appears in the Logging tab on the Command and Telemetry Server.</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Filename</td>
      <td>Ruby file to use when instantiating a new log writer</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Parameters</td>
      <td>Optional parameters to pass to the log writer class when instantiating it.</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">PACKET_LOG_WRITER DEFAULT packet_log_writer.rb # Default
# The default logger filename will be &lt;DATE&gt;_cosmostlm.bin and will create a new log every 1MB
PACKET_LOG_WRITER DEFAULT packet_log_writer.rb cosmos true nil 1000000
# Create a logger named COSMOS_LOG which creates a new log every 5 min (600s)
PACKET_LOG_WRITER COSMOS_LOG packet_log_writer.rb cosmos true 600
</code></pre></figure>

<h2 id="auto_interface_targets">AUTO_INTERFACE_TARGETS</h2>
<p><strong>Automatically use each target‚Äôs cmd_tlm_server.txt file to define the interface</strong></p>

<p>Look for a cmd_tlm_server.txt file at the top level of each target directory and use this file to configure the interface for that target. This is a good way of keeping the knowledge of how to interface to a target within that target. However, if you use substitute target names (by using DECLARE_TARGET) or use different IP addresses then this will not work and you‚Äôll have to use the INTERFACE_TARGET or INTERFACE keyword.</p>

<h2 id="interface_target">INTERFACE_TARGET</h2>
<p><strong>Load the specified target‚Äôs cmd_tlm_server.txt configuration file</strong></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Target Name</td>
      <td>Name of the target<br /><br />Valid Values: <span class="values">Any Target Name</span></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Configuration File</td>
      <td>Configuration file name which contains the interface configuration. Defaults to ‚Äòcmd_tlm_server.txt‚Äô.</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">INTERFACE_TARGET COSMOS # Look in the COSMOS target directory for cmd_tlm_server.txt
INTERFACE_TARGET COSMOS config.txt # Look in the COSMOS target directory for config.txt
</code></pre></figure>

<h2 id="interface">INTERFACE</h2>
<p><strong>Defines a connection to a physical target</strong></p>

<p>Interfaces are what COSMOS uses to talk to a particular piece of hardware. Interfaces require a Ruby file which implements all the interface methods necessary to talk to the hardware. COSMOS defines many built in interfaces or you can define your own as long as it implements the interface protocol.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Interface Name</td>
      <td>Name of the interface. This name will appear in the Interfaces tab of the Server and is also referenced by other keywords. The COSMOS convention is to name interfaces after their targets with ‚Äò_INT‚Äô appended to the name, e.g. INST_INT for the INST target.</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Filename</td>
      <td>Ruby file to use when instantiating the interface.<br /><br />Valid Values: <span class="values">tcpip_client_interface.rb, tcpip_server_interface.rb, udp_interface.rb, serial_interface.rb, cmd_tlm_server_interface.rb, linc_interface.rb</span></td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Additional parameters are required. Please see the <a href="/docs/interfaces">Interfaces</a> documentation for more details.</p>

<h2 id="router">ROUTER</h2>
<p><strong>Create an interface which reverses cmd/tlm data</strong></p>

<p>Router creates an interface which receives command packets from their remote targets and send them out their interfaces. They receive telemetry packets from their interfaces and send them to their remote targets. This allows routers to be intermediaries between an external client and an actual device.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Name</td>
      <td>Name of the router</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Filename</td>
      <td>Ruby file to use when instantiating the interface.<br /><br />Valid Values: <span class="values">tcpip_client_interface.rb, tcpip_server_interface.rb, udp_interface.rb, serial_interface.rb, cmd_tlm_server_interface.rb, linc_interface.rb</span></td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<p>Additional parameters are required. Please see the <a href="/docs/interfaces">Interfaces</a> documentation for more details.</p>

<h2 id="collect_metadata">COLLECT_METADATA</h2>
<p><strong>Prompts the user for meta data when starting the Command and Telemetry Server</strong></p>

<h2 id="background_task">BACKGROUND_TASK</h2>
<p><strong>Create a background task in the Command and Telemetry Server</strong></p>

<p>The Server instantiates the class which must inherit from BackgroundTask and then calls the call() method which the class must implement. The call() method is only called once so if your background task is supposed to live on while the Server is running, you must implement your code in a loop with a sleep to not use all the CPU.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Filename</td>
      <td>Ruby file which contains the background task implementation. Must inherit from BackgroundTask and implement the call method.</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Optional Arguments</td>
      <td>Optional arguments to the background task constructor</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<p>Example Usage:</p>
<figure class="highlight"><pre><code class="language-bash" data-lang="bash">BACKGROUND_TASK example_background_task.rb</code></pre></figure>

<h3 id="interface-modifiers">INTERFACE Modifiers</h3>
<p>The following keywords must follow a INTERFACE keyword.</p>

<h3 id="target">TARGET</h3>
<p><strong>Maps a target name to an interface</strong></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Target Name</td>
      <td>Target name to map to this interface<br /><br />Valid Values: <span class="values">Any Target Name</span></td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h3 id="dont_connect">DONT_CONNECT</h3>
<p><strong>Server will not automatically try to connect to the interface at startup</strong></p>

<h3 id="dont_reconnect">DONT_RECONNECT</h3>
<p><strong>Server will not try to reconnect to the interface if the connection is lost</strong></p>

<h3 id="reconnect_delay">RECONNECT_DELAY</h3>
<p><strong>Reconnect delay in seconds</strong></p>

<p>If DONT_RECONNECT is not present the Server will try to reconnect to an interface if the connection is lost. Reconnect delay sets the interval in seconds between reconnect tries.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Delay</td>
      <td>Delay in seconds between reconnect attempts. The default is 15 seconds.</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h3 id="disable_disconnect">DISABLE_DISCONNECT</h3>
<p><strong>Disable the Disconnect button on the Interfaces tab in the Server</strong></p>

<p>Use this keyword to prevent the user from disconnecting from the interface. This is typically used in a ‚Äòproduction‚Äô environment where you would not want the user to inadvertantly disconnect from a target.</p>

<h3 id="log">LOG</h3>
<p><strong>Enable logging on the interface by the specified log writer</strong></p>

<p>LOG is only required if you want a log writer other than the default to log commands and telemetry on this interface</p>

<div class="note warning"><p>Choosing a custom log writer can prevent COSMOS from reading back your log files</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Name</td>
      <td>Log writer name as defined by PACKET_LOG_WRITER</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h3 id="log_stored">LOG_STORED</h3>
<p><strong>Enable logging of stored telemetry on the interface by the specified log writer</strong></p>

<p>LOG_STORED allows you to specify a different log writer for stored telemetry (telemetry which has the ‚Äòstored‚Äô flag set in the packet). By default the stored telemetry is intermingled in the normal log file.</p>

<div class="note warning"><p>Choosing a custom log writer can prevent COSMOS from reading back your log files</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Name</td>
      <td>Log writer name as defined by PACKET_LOG_WRITER</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h3 id="dont_log">DONT_LOG</h3>
<p><strong>Disable logging commands and telemetry on this interface</strong></p>

<h3 id="log_raw">LOG_RAW</h3>
<p><strong>Log all data on the interface exactly as it is sent and received</strong></p>

<p>LOG_RAW does not add any COSMOS headers and thus can not be read by COSMOS tools. It is primarily useful for low level debugging of an interface. You will have to manually parse these logs yourself using a hex editor or other application.</p>

<h3 id="protocol">PROTOCOL</h3>
<div class="right">(Since 4.0.0)</div>
<p><strong>Protocols modify the interface by processing the data</strong></p>

<p>Protocols can be either READ, WRITE, or READ_WRITE. READ protocols act on the data received by the interface while write acts on the data before it is sent out. READ_WRITE applies the protocol to both reading and writing.<br /><br /> There is only one built in protocol implemented by override_protocol.rb. This protocol allows for Scripts to use the override_tlm() and normalize_tlm() methods to permanently change a telemetry value. Note, this differs from set_tlm() as set_tlm() is over-written by new incoming telemetry.<br /><br /> For information on creating your own custom protocol please see <a href="http://cosmosrb.com/docs/protocols">cosmosrb.com/docs/protocols</a></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Type</td>
      <td>Whether to apply the protocol on incoming data, outgoing data, or both<br /><br />Valid Values: <span class="values">READ, WRITE, READ_WRITE</span></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Protocol Filename or Classname</td>
      <td>Ruby file name or class name which implements the protocol</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Protocol specific parameters</td>
      <td>Additional parameters used by the protocol</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<h3 id="option">OPTION</h3>
<p><strong>Set a parameter on an interface</strong></p>

<p>When an option is set the interface class calls the set_option method. Custom interfaces can override set_option to handle any additional options they want.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Name</td>
      <td>The option to set. COSMOS defines several options on the core provided interfaces. The SerialInterface defines FLOW_CONTROL which can be NONE (default) or RTSCTS, STRUCT to directly set fields in the Windows DCB or POSIX structure and it defines DATA_BITS which changes the data bits of the serial interface. The TcpipServerInterface defines LISTEN_ADDRESS which is the IP address to accept connections on (default 0.0.0.0) and AUTO_SYSTEM_META which will automatically send SYSTEM META when the interface connects (default false).</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Parameters</td>
      <td>Parameters to pass to the option</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<h3 id="router-modifiers">ROUTER Modifiers</h3>
<p>The following keywords must follow a ROUTER keyword.</p>

<h3 id="route">ROUTE</h3>
<p><strong>Map an interface to a router</strong></p>

<p>Once an interface has been mapped to a router, all its received telemetry will be sent out through the router.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Interface</td>
      <td>Name of the interface</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h3 id="target-1">TARGET</h3>
<p><strong>Maps a target name to an interface</strong></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Target Name</td>
      <td>Target name to map to this interface<br /><br />Valid Values: <span class="values">Any Target Name</span></td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h3 id="dont_connect-1">DONT_CONNECT</h3>
<p><strong>Server will not automatically try to connect to the interface at startup</strong></p>

<h3 id="dont_reconnect-1">DONT_RECONNECT</h3>
<p><strong>Server will not try to reconnect to the interface if the connection is lost</strong></p>

<h3 id="reconnect_delay-1">RECONNECT_DELAY</h3>
<p><strong>Reconnect delay in seconds</strong></p>

<p>If DONT_RECONNECT is not present the Server will try to reconnect to an interface if the connection is lost. Reconnect delay sets the interval in seconds between reconnect tries.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Delay</td>
      <td>Delay in seconds between reconnect attempts. The default is 15 seconds.</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h3 id="disable_disconnect-1">DISABLE_DISCONNECT</h3>
<p><strong>Disable the Disconnect button on the Interfaces tab in the Server</strong></p>

<p>Use this keyword to prevent the user from disconnecting from the interface. This is typically used in a ‚Äòproduction‚Äô environment where you would not want the user to inadvertantly disconnect from a target.</p>

<h3 id="log-1">LOG</h3>
<p><strong>Enable logging on the interface by the specified log writer</strong></p>

<p>LOG is only required if you want a log writer other than the default to log commands and telemetry on this interface</p>

<div class="note warning"><p>Choosing a custom log writer can prevent COSMOS from reading back your log files</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Name</td>
      <td>Log writer name as defined by PACKET_LOG_WRITER</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h3 id="log_stored-1">LOG_STORED</h3>
<p><strong>Enable logging of stored telemetry on the interface by the specified log writer</strong></p>

<p>LOG_STORED allows you to specify a different log writer for stored telemetry (telemetry which has the ‚Äòstored‚Äô flag set in the packet). By default the stored telemetry is intermingled in the normal log file.</p>

<div class="note warning"><p>Choosing a custom log writer can prevent COSMOS from reading back your log files</p></div>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Name</td>
      <td>Log writer name as defined by PACKET_LOG_WRITER</td>
      <td>True</td>
    </tr>
  </tbody>
</table>

<h3 id="dont_log-1">DONT_LOG</h3>
<p><strong>Disable logging commands and telemetry on this interface</strong></p>

<h3 id="log_raw-1">LOG_RAW</h3>
<p><strong>Log all data on the interface exactly as it is sent and received</strong></p>

<p>LOG_RAW does not add any COSMOS headers and thus can not be read by COSMOS tools. It is primarily useful for low level debugging of an interface. You will have to manually parse these logs yourself using a hex editor or other application.</p>

<h3 id="protocol-1">PROTOCOL</h3>
<div class="right">(Since 4.0.0)</div>
<p><strong>Protocols modify the interface by processing the data</strong></p>

<p>Protocols can be either READ, WRITE, or READ_WRITE. READ protocols act on the data received by the interface while write acts on the data before it is sent out. READ_WRITE applies the protocol to both reading and writing.<br /><br /> There is only one built in protocol implemented by override_protocol.rb. This protocol allows for Scripts to use the override_tlm() and normalize_tlm() methods to permanently change a telemetry value. Note, this differs from set_tlm() as set_tlm() is over-written by new incoming telemetry.<br /><br /> For information on creating your own custom protocol please see <a href="http://cosmosrb.com/docs/protocols">cosmosrb.com/docs/protocols</a></p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Type</td>
      <td>Whether to apply the protocol on incoming data, outgoing data, or both<br /><br />Valid Values: <span class="values">READ, WRITE, READ_WRITE</span></td>
      <td>True</td>
    </tr>
    <tr>
      <td>Protocol Filename or Classname</td>
      <td>Ruby file name or class name which implements the protocol</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Protocol specific parameters</td>
      <td>Additional parameters used by the protocol</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<h3 id="option-1">OPTION</h3>
<p><strong>Set a parameter on an interface</strong></p>

<p>When an option is set the interface class calls the set_option method. Custom interfaces can override set_option to handle any additional options they want.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Name</td>
      <td>The option to set. COSMOS defines several options on the core provided interfaces. The SerialInterface defines FLOW_CONTROL which can be NONE (default) or RTSCTS, STRUCT to directly set fields in the Windows DCB or POSIX structure and it defines DATA_BITS which changes the data bits of the serial interface. The TcpipServerInterface defines LISTEN_ADDRESS which is the IP address to accept connections on (default 0.0.0.0) and AUTO_SYSTEM_META which will automatically send SYSTEM META when the interface connects (default false).</td>
      <td>True</td>
    </tr>
    <tr>
      <td>Parameters</td>
      <td>Parameters to pass to the option</td>
      <td>False</td>
    </tr>
  </tbody>
</table>

<h3 id="background_task-modifiers">BACKGROUND_TASK Modifiers</h3>
<p>The following keywords must follow a BACKGROUND_TASK keyword.</p>

<h3 id="stopped">STOPPED</h3>
<p><strong>Indicate the background task should not be automatically started</strong></p>

<h1 id="project-crc-checking">Project CRC Checking</h1>
<p>The COSMOS Launcher will check CRCs on project files if a data/crc.txt file is present. The file is made up of filename, a space character, and the expected CRC for the file. If the user updates the file from the Launcher legal dialog, the keyword USER_MODIFIED will be added to the top. This line should be deleted for an official release.</p>

<p>Example File:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">lib/example_background_task.rb 0xCF0A70AF
lib/example_target.rb 0x5B7507D3
lib/user_version.rb 0x8F282EE9</code></pre></figure>

:ET